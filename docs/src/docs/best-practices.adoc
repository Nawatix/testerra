= Best Practices

This section contains several articles for best practices for the usage and implementation of tests with Testerra.

== Project setup

Project setup recommendations.

=== Normalize file encoding

Always use the same file encoding for all your source file types like `.html`, `.properties`, `.java` etc.

IntelliJ: You can change the default encoding for files at _File -> Settings -> File Encodings_

=== Normalize file endings

Prevent using default line ending `CRLF` on Windows.

Git: Setup `git config --global core.autocrlf input` to prevent any commited CRLF.

== Support multiple profiles

Supporting multiple profiles is useful, for different environments or test suites.

.build.gradle
[source,gradle,role="primary"]
----
test {
    def profiles = [
        "mySuite": "suite.xml"
    ]

    def suiteFiles = []
    profiles.each { k, v ->
        if (project.hasProperty("" + k)) {
            def f = 'src/test/resources/' + v
            suiteFiles << f
        }
    }

    useTestNG() {
        suites(suiteFiles as String[])
    }
}
----

.pom.xml
[source,xml,role="secondary"]
----
<project>
   <profiles>
        <profile>
            <id>mySuite</id>
            <build>
                <plugins>
                    <plugin>
                        <artifactId>maven-surefire-plugin</artifactId>
                        <configuration>
                            <skip>false</skip>
                            <suiteXmlFiles>
                                <suiteXmlFile>src/test/resources/suite.xml</suiteXmlFile>
                            </suiteXmlFiles>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>
----

.Gradle
[source,bash,role="primary"]
----
gradle test -PmySuite
----

.Maven
[source,bash,role="secondary"]
----
mvn test -PmySuite
----

== Quality Assurance Attributes

As we know, things changing all the time.
And in the context of a website, it may also change in several ways

* Layout
* Design
* Features

=== Problem

The features of a website are covered by functional tests based on GuiElements.
But GuiElements are using identifiers based on the Document Object Model (DOM) of the website.
The DOM is based on HTML elements and can vary between static and highly dynamic.
That means, if the layout or design changes, the DOM may also change and in consequence also the identifiers of the GuiElements which affects the functionality of the tests.

WARNING: Tests covering features may break if the layout or design changes.

_Layout Change_ -> _DOM Change_ -> _Identifier Change_ -> _GuiElement not working as expected_

Changing identifiers carry the following additional risks:

- _False Negative_: Tests failing, even if the feature is not broken
- _Sisyphus work_: Test engineers must consistently update the identifiers
- _No coverage_: The features and the tests are mostly out of sync.

=== Solution

To prevent these risks above, it's a good practice to introduce a more stable form of identifiers based on the non-standard HTML `@data-qa` attribute.

* These attributes are stable and don't change, even if the DOM changes.
* It enhances the DOM with more semantic features.
* They don't affected any other attributes like `@id` or `@class`.
* They are independet of the underlaying framework like Bootstrap, Angular or whatsoever.
* They can be easily removed in Live environments.

NOTE: Developers should integrate these attributes in their HTML code.

=== Recommendation

We recommend a syntax, there the `@data-qa` tag contains 3 parts separated by slash (/) to describe it's behaviour.

`data-qa="[type]/[name]/[id?]"`

Where `name` and `id` are free to define, `type` is not and should be one of these semantic types.

==== Semantics

[cols="1,2,4a"]
|===
| Prefix | Description | Examples
| section | Non-interactive area with content
| [source, html]
----
<article data-qa="section/article">
----
| input | Interactive input elements
|
[source,html]
----
<input data-qa="input/searchQuery"/>
----
| action | Interative elements that performs an action
|
[source,html]
----
<button data-qa="action/login">Login</button>
<a href="https://google.com" data-qa="action/gotoGoogle">Search at Google</a>
----
|===

==== Example

[source,html]
----
<ul>
    <li data-qa="section/animal/ape">
        <h1 data-qa="section/headline">Ape</h1>
        <p data-qa="section/description">Hairy and Goofy</p>
        <button data-qa="action/gotoDetails">Details</button>
    </li>
</ul>
----

You can select this item by using the `Locate` extension.

[source,java]
----
new GuiElement(driver, Locate.by().qa("section/animal/ape"));
----

== Always prefer Assertions

If you need to check several properties of a GuiElement, always prefer

. <<Assertions>> due to the human-readable and precise description
. over <<Waiters>> because of their fault tolerance
. over <<Checks>>

[source,java]
----
// Good practice
element.asserts().assertText("Search results");

// Bad practice
Assert.assertTrue(element.getText().contains("Search results"));
----

== Always describe your asserts

In that specific case where you can't use `asserts()`, then use the extended <<Assert Utilities>> to more precise in your statement and pass a proper description text.

[source,java]
----
int actualSearchResultCount = Integer.parseInt(element.getText());

// Good practice
AssertUtils.assertGreaterThan(actualSearchResultCount, 5, "Search results count");

// Bad practice
Assert.assertTrue(actualSearchResultCount > 5);
----

== Working with HTML elements

=== Radio buttons

Since radio buttons share the same name, as the following example shows

[source,html]
----
<input type="radio" name="beverage" value="tee">
<input type="radio" name="beverage" value="coffee">
----

It's not a good practice to select it `By.name`.
Its better to select both options separately.

[source,java]
----
// Good practice
Locate locator = Locate.prepare("//input[@name='%s' and @value='%s']").unique();
GuiElement teeOption = new GuiElement(driver, locator.with("beverage", "tee"));
GuiElement coffeeOption = new GuiElement(driver, locator.with("beverage", "coffee"));

// Bad practice
GuiElement options = new GuiElement(driver, By.name("beverage"));
----

=== Shadow Roots

Modern web applications are allowed to use some third-party components, which can be integrated with Shadow DOM.
This is the modern art of an iframe, because the components will be loaded via asynchronous JavaScript.

Each embedded Shadow DOM component will have it's own shadow root.
To work with shadow root elements Testerra provide the method `shadowRoot()` on the `GuiElement` class.

Given the following HTML code snippet it will be easier how to get the corresponding `GuiElement` of the Shadow DOM component.

.HTML Code
[source,html]
----
<body>
    <div id="wrapper">
    <!-- HTML code-->
    <my-custom-shadow-root-element>
    <!-- #shadowRoot -->
        <div class="custom-component">
            <input id="custom-component-login-name" name="name">
        </div>
    </my-custom-shadow-root-element>
    </div>
    <!-- HTML code-->
</body>
----

.Java Code
[source,java]
----
WebDriver driver = WebDriverManager.getWebDriver();

GuiElement shadowRootElement = new GuiElement(driver, By.cssSelector("my-custom-shadow-root-element")).shadowRoot();
GuiElement inputName = shadowRootElement.getSubElement(By.cssSelector("#custom-component-login-name"));
----

IMPORTANT: Calling `isDisplayed()` on `shadowRoot()`-notated `GuiElement` will always return false, but `isPresent()` will work as designed.

