= Changes

== New API (Draft)

This is a draft of the new Testerra API.
The main goal for re-inventing the GuiElement API was at first, to provide a better user experience for
implementing tests scripts in the role of a Test Engineer.

Automated testing on web pages is hard, especially on large enterprise environments we address with Testerra.
And yes, we know the trouble what happens when tests (suddenly) fails.

As an Test Engineer, you may want expressive info messages for bugs in the System under Test or to keep your tests up to date to the
specification. You may need easy to understand test code and a robust extensible Page Object model for large test environments
by keeping the full potential of a Software Developer?

The new Testerra API provides them all.

If you're a developer and want to know how the new API works, you can jump straight to <<The internals>> or just proceed with the next chapter to get an overview.

=== Pages instantiation

The new standard way to instantiate Pages is now
```java
class MyTest extends TesterraTest {
    @Test
    public void test_MyPageTest() {
        MyPage page = pageFactory.create(MyPage.class);

        // Or with different WebDriver
        MyPage page = pageFactory.create(MyPage.class, WebDriverManager.getWebDriver());
    }
}
```
Within Pages
```java
class MyPage extends Page {
    public AnotherPage navigateToAnotherPage() {
        return createPage(AnotherPage.class);
    }
}
```

[NOTE]
.Using the static `PageFactory` is now `@deprecated`
====
```java
MyPage page = PageFactory.create(MyPage.class, WebDriverManager.getWebDriver());
```
====

[NOTE]
.Passing variables to the Page constructor is now `@deprecated`
====
```java
MyPage page = PageFactory.create(
    MyPage.class,
    WebDriverManager.getWebDriver(),
    new PageVariables()
);
```
====

[CAUTION]
.Constructor instantiation of Pages is forbidden!
====
```java
MyPage page = new MyPage(WebDriverManager.getWebDriver());
```
====

=== Sub Pages
The new standard way to implement Sub Pages aka Components is now
```java
public class MyForm extends Component {
    public MyForm(IGuiElement rootElement) {
        super(rootElement);
    }
}
```
Instantiate components
```java
class MyPage extends Page {
    private MyForm form = withAncestor(find(By.tagName("form"))).createComponent(MyForm.class);
}
```

=== Implicit Element checks

The standard way of implicit GuiElement checks is now
```java
class MyPage extends Page {
    @Check
    private IGuiElement guiElement = findById(42);
}
```

[CAUTION]
.Performing explicit page checks is forbidden!
====
```java
class MyPage extends Page {
    public MyPage(WebDriver webDriver) {
        super(webDriver);
        checkPage(); <1>
    }
}

MyPage page = pageFactory.create(MyPage.class);
page.checkPage(); <2>
```
<1> Calling `checkPage()` as `protected` member is forbidden
<2> Calling `checkPage()` as `public` member is forbidden
====

=== Element instantiation

The new standard way to instantiate GuiElements is now
```java
class MyPage extends Page {
    private IGuiElement guiElement = findById(42);
    private IGuiElement guiElement = find(By.xpath("//div[1]"));
}
```

[NOTE]
.Constructor instantiation of GuiElements is now `@deprecated`
====
```java
class MyPage extends Page {
    private GuiElement guiElement = new GuiElement(By.id(42), driver);
    private GuiElement guiElement = new GuiElement(By.xpath("//div[1]"), driver);
}
```
====

For sub elements
```java
class MyPage extends Page {
    private IGuiElement guiElement = findById(42);
    private IGuiElement subElement = withAncestor(guiElement).find(By.xpath("//div[1]"));
}
```

[NOTE]
.Retrieving sub elements from GuiElement is now `@deprecated`
====
```java
class MyPage extends Page {
    private GuiElement guiElement = new GuiElement(By.id(42), driver);
    private GuiElement subElement = guiElement.getSubElement(By.xpath("//div[1]"));
}
```
====

For elements in frames
```java
class MyPage extends Page {
    private IGuiElement frame = find(By.tagName("frame"));
    private IGuiElement guiElement = inFrame(frame).findById(14);
}
```

[NOTE]
.Passing frames to the constructor is now `@deprecated`
====
```java
class MyPage extends Page {
    private GuiElement frame = new GuiElement(By.tagName("frame"), driver);
    private GuiElement guiElement = new GuiElement(By.id(14), driver, frame);
}
```
====

=== Assertions

The new standard way for performing assertions in Tests or Pages is now
```java
Assert.assertTrue(false);
```

==== Element Assertions

The new standard way to perform assertions on elements like Pages and GuiElements is now
```java
guiElement.displayed().isTrue(); <1>
guiElement.value().contains("Hallo Welt"); <2>
page.url().endsWith("index.html"); <3>
page.anyElementContainsText("You see me").displayed().isTrue(); <4>
```
[NOTE]
.Using the GuiElement assertions is now `@deprecated`
====
```java
guiElement.asserts().assertIsDisplayed(); <1>
guiElement.asserts().assertAttributeContains("value", "Hallo Welt"); <2>
Assert.assertTrue(page.getWebDriver().getCurrentUrl().endsWith("index.html")); <3>
page.assertIsTextDisplayed("You see me"); <4>
```
====

Perform decisions on occurrence with the `waitFor` prefix.
```
if (guiElement.waitFor().displayed().isTrue()) {
    // Optional element became visible
}
```
[NOTE]
.Using the GuiElement waits is now `@deprecated`
====
```java
if (guiElement.waits().waitForIsDisplayed()) {
}
```
====

Support of more features through consistent assertion API
```java
guiElement.css("display").is("none"); <1>
guiElement.text().matches("^Hello\\s.orld").isTrue(); <2>
page.anyElementContainsText("You see me").numberOfElements().is(1); <3>
```
<1> Perform assertions on the element's CSS properties
<2> Regular expression assertions
<3> Perform GuiElement assertions on found text nodes

==== Screenshot based Assertions
The new standard way to perform screenshot based assertions is now
```java
guiElement.screenshot().pixelDistance("ElementReference").isLowerThan(1);
page.screenshot().pixelDistance("PageReference").isBetween(0, 10);
```

Add screenshot to the report
```java
page.screenshot().toReport();
```
[NOTE]
.Using the static `UITestUtils` is now `@deprecated`
====
```java
UITestUtils.takeScreenshot(page.getWebDriver(), true);
```
====

==== Layout based Assertions
The new standard way to perform layout based assertions is now
```java
left.bounds().leftOf(right).isTrue(); <1>
left.bounds().fromRight().toRightOf(right).is(0); <2>
parent.bounds().contains(child).isTrue();
left.bounds().intersects(right).isFalse();
```
[NOTE]
.Using the `assertLayout()` method is now `@deprecated`
====
```java
left.asserts().assertLayout(Layout.outer().leftOf(right)); <1>
left.asserts().assertLayout(Layout.outer().sameRight(right, 0)); <2>
```
====

==== Collected Assertions

The new standard way to collect assertions of GuiElements in Tests or Pages is now
```java
Control.collectAssertions(() -> guiElement.displayed().isTrue());
```

For many GuiElements or Pages
```java
Control.collectAssertions(() -> {
    MyPage page = pageFactory.create(MyPage.class);
    page.title().is("TestPage");
    guiElement.value().contains("Hello");
});
```

For custom assertions
```java
Control.collectAssertions(() -> {
    String data = loadSomeData();
    Assert.assertEquals(data, "Hello World", "some data");
});
```

For other test methods
```java
@Test
public void test_CollectEverything() {
    Control.collectAssertions(() -> test_TestSomething());
}
```

[NOTE]
.Using the static `AssertCollector` is now `@deprecated`
====
```java
AssertCollector.assertTrue(false);
```
====

[NOTE]
.Using the GuiElement's assert collector is now `@deprecated`
====
```java
guiElement.assertCollector().assertIsDisplayed();
```
====

[NOTE]
.Forcing standard assertions is now `@deprecated`
====
```java
page.forceGuiElementStandardAsserts();
```
====

[NOTE]
.Setting collected assertions by default is now `@deprecated`
====
```properties
tt.guielement.default.assertcollector=true
```
====

==== Non Functional Assertions

The new standard way for non functional assertions works like <<Collected Assertions>>
```java
Control.nonFunctional(() -> guiElement.displayed().isTrue());
```

[NOTE]
.Using the static `NonFunctionalAssert` is now `@deprecated`
====
```java
Control.NonFunctionalAssert.assertTrue(false);
```
====

[NOTE]
.Using the GuiElement's non functional asserts are now `@deprecated`
====
```java
guiElement.nonFunctionalAsserts().assertIsDisplayed();
```
====

==== Advanced Topics on Assertions
Perform assertions outside of Pages or Tests
```java
public MyClass {
    @Inject
    public MyClass(Assertion assertion) {
        assertion.assertTrue(false);
    }
}
```
For non-injectable classes
```java
public MyClass {
    private final Assertion assertion = Testerra.injector.getInstance(Assertion.class);
    public MyClass() {
        assertion.assertTrue(false);
    }
}
```
Force performing explicit assertions
```java
public MyClass {
    @Inject
    public MyClass(
        NonFunctionalAssertion nonFunctional,
        CollectedAssertion collected,
        InstantAssertion instant
    ) {
        nonFunctional.assertTrue(false);
        collected.assertTrue(false);
        instant.assertTrue(false);
    }
}
```

=== Timeouts

The new standard way for setting GuiElement timeouts is now

```java
class MyPage extends Page {
    @Check(timeout = 1)
    private IGuiElement guiElement;
}
```
[NOTE]
.Setting and restoring explicit timeouts on the GuiElement is now `@deprecated`
====
```java
guiElement.setTimeoutInSeconds(1);
guiElement.restoreDefaultTimeout();
```
====
For the whole Page
```java
@PageOptions(elementTimeoutInSeconds = 1)
class MyPage extends Page {...}
```
[NOTE]
.Setting explicit timeouts on the Page is now `@deprecated`
====
```java
page.setElementTimeoutInSeconds(1);
```
====

Override during runtime
```java
Control.withElementTimeout(1, () -> guiElement.displayed().isTrue());
```

For many GuiElements or Pages
```java
Control.withElementTimeout(1, () -> {
    MyPage page = pageFactory.create(MyPage.class);
    page.title().is("TestPage");
    guiElement.value().contains("Hello");
});
```

For other test methods
```java
@Test
public void test_TestSomething_fast() {
    Control.withElementTimeout(1, () -> test_TestSomething());
}
```

[NOTE]
.Setting timeouts using static `POConfig` is now `@deprecated`
====
```java
POConfig.setThreadLocalUiElementTimeoutInSeconds(1);
POConfig.setUiElementTimeoutInSeconds(1);
POConfig.removeThreadLocalUiElementTimeout();
```
====

=== The internals

This chapter explains how the new API works internally.

==== Everything is timed, but once
Every assertions is performed multiple times with a maximum timeout of {element_timeout_seconds}.
If this timeout has reached, the assertion will finally fail.

But there is only one timeout for each assertion now. No more implicit timeouts on sub method calls like `getWebElement()`, `isPresent()` etc.

This is what an assertion internally does, when you perform `guiElement.text().contains("Something")`.

. Find web element using WebDriver
. Check if element is present
. Retrieve the text of the element
. If the text does not contain "Something", start over with 1.
. Otherwise when the timeout has reached, an assertion error message will be displayed that the
text of the element you're looking for doesn't contain the string "Something".

==== More consistence, less complexity

There will be only one interface for everything you need in a manner of
an easy to read fluent API. It is not too abstract like TestNG Assert, and not to technically like AssertJ.

The new interface will always act exactly like you expect to, no matter in which context you are.
You don't have to decide which method you should use. The standard way will be the best fit for most cases. Let the framework handle the workarrounds for you.

==== Strict Page Object pattern

Testerra was built with the Page Object pattern in mind. The new API makes it easier for your team, to keep you on track
makes it harder to break out, even if your project contains hundreds of Pages and thousands of Tests.

The new components extension allows you to implement Page Objects like the Web Developer would do by separating
functionality into reusable components.

==== Smaller codebase and less boilerplate
The API provides abstract assertion implementations for several properties.

. `StringAssertion` allows you to perform assertions on strings like `contains("Something")`
. `QuantityAssertion` allows you to perform assertions on quantified values like `isBetween(-2,3)`
. `BinaryAssertion` allows to assert if an value is boolean or a string that represents a boolean value with `isTrue()`

These generic assertions are used in many other assertions and supports a hierarchical order.
This is what the hierarchy looks like when you perform `guiElement.screenshot().file().extension().is("png")`

. Take a screenshot and return a `ScreenshotAssertion`
. Return a generic `FileAssertion` with the taken screenshot file
. Return a generic `StringAssertion` with the given file name extension

This implementation helps to keep the internal assertion code small, easy extensible and maintainable.

==== Dependency Injection

We want to make Testerra more SOLID. Thats why we finally introduced Dependency Injection via. Google Guice.
