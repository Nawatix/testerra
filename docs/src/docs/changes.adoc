= Changes

== New API (Draft)

This is a draft of the new Testerra API.
The main goal for re-inventing the GuiElement API was at first, to provide a better user experience for
implementing tests scripts in the role of a Test Engineer.

Automated testing on web pages is hard, especially on large enterprise environments we address with Testerra.
And yes, we know the trouble what happens when tests (suddenly) fails.

As an Test Engineer, you may want expressive info messages for bugs in the System under Test or to keep your tests up to date to the
specification. You may need easy to understand test code and a robust extensible Page Object model for large test environments
by keeping the full potential of a Software Developer?

The new Testerra API provides them all.

If you're a developer and want to know how the new API works, you can jump straight to <<The internals>> or just proceed with the next chapter to get an overview.

=== Pages instantiation

The new standard way to instantiate Pages is now
```java
class MyTest extends TesterraTest {
    @Test
    public void test_MyPageTest() {
        MyPage page = pageFactory.create(MyPage.class);

        // Or with different WebDriver
        MyPage page = pageFactory.create(MyPage.class, WebDriverManager.getWebDriver());
    }
}
```
Within Pages
```java
class MyPage extends Page {
    public AnotherPage navigateToAnotherPage() {
        return createPage(AnotherPage.class);
    }
}
```

[NOTE]
.Using the static `PageFactory` is now `@deprecated`
====
```java
MyPage page = PageFactory.create(MyPage.class, WebDriverManager.getWebDriver());
```
====

[NOTE]
.Passing variables to the Page constructor is now `@deprecated`
====
```java
MyPage page = PageFactory.create(
    MyPage.class,
    WebDriverManager.getWebDriver(),
    new PageVariables()
);
```
====

[CAUTION]
.Constructor instantiation of Pages is prohibited!
====
```java
MyPage page = new MyPage(WebDriverManager.getWebDriver());
```
====

=== Sub Pages
The new standard way to implement Sub Pages aka Components is now
```java
public class MyForm extends AbstractComponent<MyForm> {
    public MyForm(UiElement rootElement) {
        super(rootElement);
    }

    @Override
    protected MyForm self() {
        return this;
    }
}
```
Instantiate components
```java
class MyPage extends Page {
    private MyForm form = createComponent(MyForm.class, find(By.tagName("form")));
}
```

=== Implicit Element checks

The standard way of implicit GuiElement checks is now
```java
class MyPage extends Page {
    @Check
    private UiElement uiElement = findById(42);
}
```

[CAUTION]
.Performing explicit page checks is prohibited!
====
```java
class MyPage extends Page {
    public MyPage(WebDriver webDriver) {
        super(webDriver);
        checkPage(); <1>
    }
}

MyPage page = pageFactory.create(MyPage.class);
page.checkPage(); <2>
```
<1> Calling `checkPage()` as `protected` member is prohibited
<2> Calling `checkPage()` as `public` member is prohibited
====

=== Element instantiation

The new standard way to instantiate GuiElements is now
```java
class MyPage extends Page {
    private UiElement uiElement = findById(42);
    private UiElement uiElement = find(By.xpath("//div[1]"));
}
```

[NOTE]
.Constructor instantiation of GuiElements is now `@deprecated`
====
```java
class MyPage extends Page {
    private GuiElement guiElement = new GuiElement(By.xpath("//div[1]"), driver);
}
```
====

For descendant elements
```java
class MyPage extends Page {
    private UiElement parent = findById(42);
    private UiElement sub = parent.find(By.xpath("//div[1]"));
}
```

[NOTE]
.`getSubElement` is now `@deprecated`
====
```java
class MyPage extends Page {
    private GuiElement parent = new GuiElement(By.id(42), driver);
    private GuiElement sub = parent.getSubElement(By.xpath("//div[1]"));
}
```
====

List elements
```java
UiElement anchors = find(By.tagName("a"));

anchors.numberOfElements().is(3); <1>
anchors.list().first().value(Attribute.TITLE).is("StartPage"); <2>
anchors.list().get(1).value(Attribute.TITLE).is("About Us"); <3>
anchors.list().last().value(Attribute.TITLE).is("Contact"); <4>

anchors.list().forEach(anchor -> anchor.value(Attribute.HREF).beginsWith("https")); <5>
```

[NOTE]
.GuiElement lists are now `@deprecated`
====
```java
GuiElement anchors = new GuiElement(driver, By.tagName("a"));

Assert.assertEquals(anchors.getNumberOfFoundElements(), 3); <1>

List<GuiElement> list = anchor.getList();
list.get(0).asserts().assertAttributeValue("title", "StartPage"); <2>
list.get(1).asserts().assertAttributeValue("title", "About Us"); <3>
list.get(list.size()-1).asserts().assertAttributeValue("title", "Contact"); <4>

list.forEach(anchor -> Assert.assertTrue(anchor.getAttribute("href").startsWith("https"))); <5>
```
====
For elements in frames
```java
class MyPage extends Page {
    private UiElement frame = find(By.tagName("frame"));
    private UiElement uiElement = inFrame(frame).findById(14);
}
```

[NOTE]
.Passing frames to the constructor is now `@deprecated`
====
```java
class MyPage extends Page {
    private GuiElement frame = new GuiElement(By.tagName("frame"), driver);
    private GuiElement guiElement = new GuiElement(By.id(14), driver, frame);
}
```
====

=== Assertions

The new standard way for performing assertions in Tests or Pages is now
```java
Assert.assertTrue(false);
```

==== Element Assertions

The new standard way to perform assertions on elements like Pages and GuiElements is now
```java
uiElement.displayed(true); <1>
uiElement.value().contains("Hallo Welt"); <2>
page.url().endsWith("index.html"); <3>
page.anyElementContainsText("You see me").displayed(true); <4>
```
[NOTE]
.Using the GuiElement assertions is now `@deprecated`
====
```java
guiElement.asserts().assertIsDisplayed(); <1>
guiElement.asserts().assertAttributeContains("value", "Hallo Welt"); <2>
Assert.assertTrue(page.getWebDriver().getCurrentUrl().endsWith("index.html")); <3>
page.assertIsTextDisplayed("You see me"); <4>
```
====

Perform decisions on occurrence with the `waitFor` prefix.
```
if (uiElement.waitFor().displayed(true)) {
    // Optional element became visible
}
```
[NOTE]
.Using the GuiElement waits is now `@deprecated`
====
```java
if (guiElement.waits().waitForIsDisplayed()) {
}
```
====

Support of more features through consistent assertion API
```java
uiElement.css("display").is("none"); <1>
uiElement.text().map(value -> value.toLowerCase()).matches("^hello\\s.orld").is(true); <2,3>
page.anyElementContainsText("You see me").numberOfElements().is(1); <4>
```
<1> Perform assertions on the element's CSS properties
<2> Map values
<3> Regular expression assertions
<4> Perform GuiElement assertions on found text nodes

Custom failure messages
```java
uiElement.displayed(true, This element should be displayed");
```

==== Screenshot based Assertions
The new standard way to perform screenshot based assertions is now
```java
uiElement.screenshot().pixelDistance("ElementReference").isLowerThan(1);
page.screenshot().pixelDistance("PageReference").isBetween(0, 10);
```

Add screenshot to the report
```java
page.screenshot().toReport();
```
[NOTE]
.Using the static `UITestUtils` is now `@deprecated`
====
```java
UITestUtils.takeScreenshot(page.getWebDriver(), true);
```
====

==== Layout based Assertions
The new standard way to perform layout based assertions is now
```java
// Element is beside another element
UiElement left = find(By.id("left"));
UiElement right = find(By.id("right"));
left.bounds().leftOf(right).is(true); <1>
left.bounds().intersects(right).is(false);

// Elements aligned to the same right
UiElement top = find(By.id("top"));
UiElement bottom = find(By.id("bottom"));
top.bounds().fromRight().toRightOf(bottom).is(0);<2>

// Element contains another element
UiElement body = find(By.tagName("body"));
UiElement nav = parent.find(By.tagName("nav"));
body.bounds().contains(nav).is(true);
```
[NOTE]
.Using the `assertLayout()` method is now `@deprecated`
====
```java
left.asserts().assertLayout(Layout.outer().leftOf(right)); <1>
top.asserts().assertLayout(Layout.outer().sameRight(bottom, 0)); <2>
```
====

=== Control API

With the `TestController` API, you are able to control your test flow during runtime. Like timeouts, assertion handling and retry intervals.
The `Control` instance is availabe as soon you implement the `TestFeatures` interface.

```java
class MyPage extends Page implements TestFeatures {
    public void doSomething() {
        Control.collectAssertions();
    }
}
```

=== Collected Assertions

The new standard way to collect assertions of GuiElements in Tests or Pages is now
```java
Control.collectAssertions(() -> uiElement.displayed(true));
```

For many GuiElements or Pages
```java
Control.collectAssertions(() -> {
    MyPage page = pageFactory.create(MyPage.class);
    page.title().is("TestPage");
    uiElement.value().contains("Hello");
});
```

For custom assertions
```java
Control.collectAssertions(() -> {
    String data = loadSomeData();
    Assert.assertEquals(data, "Hello World", "some data");
});
```

For other test methods
```java
@Test
public void test_CollectEverything() {
    Control.collectAssertions(() -> test_TestSomething());
}
```

[NOTE]
.Using the static `AssertCollector` is now `@deprecated`
====
```java
AssertCollector.assertTrue(false);
```
====

[NOTE]
.Using the GuiElement's assert collector is now `@deprecated`
====
```java
guiElement.assertCollector().assertIsDisplayed();
```
====

[NOTE]
.Forcing standard assertions is now `@deprecated`
====
```java
page.forceGuiElementStandardAsserts();
```
====

[NOTE]
.Setting collected assertions by default is now `@deprecated`
====
```properties
tt.guielement.default.assertcollector=true
```
====

==== Non Functional Assertions

The new standard way for non functional assertions works like <<Collected Assertions>>
```java
Control.nonFunctional(() -> uiElement.displayed(true));
```

[NOTE]
.Using the static `NonFunctionalAssert` is now `@deprecated`
====
```java
NonFunctionalAssert.assertTrue(false);
```
====

[NOTE]
.Using the GuiElement's non functional asserts are now `@deprecated`
====
```java
guiElement.nonFunctionalAsserts().assertIsDisplayed();
```
====

==== Advanced Topics on Assertions
Perform assertions outside of Pages or Tests
```java
public MyClass {
    @Inject
    public MyClass(Assertion assertion) {
        assertion.assertTrue(false);
    }
}
```
For non-injectable classes
```java
public MyClass {
    private final Assertion assertion = Testerra.injector.getInstance(Assertion.class);
    public MyClass() {
        assertion.assertTrue(false);
    }
}
```
Force performing explicit assertions
```java
public MyClass {
    @Inject
    public MyClass(
        NonFunctionalAssertion nonFunctional,
        CollectedAssertion collected,
        InstantAssertion instant
    ) {
        nonFunctional.assertTrue(false);
        collected.assertTrue(false);
        instant.assertTrue(false);
    }
}
```

=== Timeouts

==== @Check timeouts

The new standard way for setting GuiElement timeouts on `@Check` is now

```java
class MyPage extends Page {
    @Check(timeout = 1)
    private UiElement uiElement;
}
```
[NOTE]
.Setting and restoring explicit timeouts on the GuiElement is now `@deprecated`
====
```java
guiElement.setTimeoutInSeconds(1);
guiElement.restoreDefaultTimeout();
```
====
For the whole Page
```java
@PageOptions(elementTimeoutInSeconds = 1)
class MyPage extends Page {...}
```
[NOTE]
.Setting explicit timeouts on the Page is now `@deprecated`
====
```java
page.setElementTimeoutInSeconds(1);
```
====

Override during runtime
```java
Control.withTimeout(1, () -> uiElement.displayed(true));
```

For many GuiElements or Pages
```java
Control.withTimeout(1, () -> {
    MyPage page = pageFactory.create(MyPage.class);
    page.title().is("TestPage");
    uiElement.value().contains("Hello");
});
```

For other test methods
```java
@Test
public void test_TestSomething_fast() {
    Control.withTimeout(1, () -> test_TestSomething());
}
```

[NOTE]
.Setting timeouts using static `POConfig` is now `@deprecated`
====
```java
POConfig.setThreadLocalUiElementTimeoutInSeconds(1);
POConfig.setUiElementTimeoutInSeconds(1);
POConfig.removeThreadLocalUiElementTimeout();
```
====

=== Retry

It sometimes happens, that you need to retry a whole sequence of operations.

```java
Control.retryFor(5, () -> {
    button.click();
    button.enabled().is(false);
);
```

That will retry to click a button for 5 seconds until it's disabled.

You can combine these features with the fluent API design, to completely disable the internal element timeout.

```java
Control.retryFor(10).withTimeout(0, () -> {
    button.click();
    guiElement.scrollIntoView();
    guiElement.visible(false).is(true);
});
```

=== New Locator interface

The new `XPath` class helps you to build failsafe xpathes optimized for HTML. But it's restricted to search elements from top down. Once you changed the
scope of an element by `contains` or `select` you cannot go back.

This is what the basic syntax looks like
```java
UiElement div = find(XPath.from("div"));
```

But it supports many other features you need when you select
elements from the DOM, like first and last element.
```java
XPath.from("td", 1);
XPath.from("td", -1);
```

==== Elements that have classes

```java
XPath.from("div").classes("navigation", "header");
```
This will find elements like
```html
<div class="header large navigation">
```
but not
```html
<div class="navigation-header">
```

==== Select an element that contains another element

```java
XPath.from("nav")
    .classes("mobile")
    .contains("div")
        .classes("navigation", "header");
```

This will find elements like
```html
<nav class="mobile"><div class="navigation header"></nav>
```

==== Select an element by its text
```java
XPath.from("*").text().words("Login", "here");
XPath.from("*").text().contains("first");
XPath.from("*").text().endsWith("here ");
```
This will find elements like
```html
<a> Login first
    here </a>
```

==== Select by attributes

```java
XPath.from("*").attribute("src").endsWith(".png");
```

This will find elements like

```html
<img src="http://example.com/image.png"/>
```

==== Select a sub element
```java
XPath.from("form")
    .attribute("name", "login") // shortcut for attribute("name").is("login")
    .select("button")
        .text().words("Login");
```
This will find elements like
```html
<form name="login">
    <button>Login here</button>
</form>
```

=== The internals

This chapter explains how the new API works internally.

==== Everything is timed, but once
Every assertions is performed multiple times with a maximum timeout of {element_timeout_seconds}.
If this timeout has reached, the assertion will finally fail.

But there is only one timeout for each assertion now. No more implicit timeouts on sub method calls like `getWebElement()`, `isPresent()` etc.

This is what an assertion internally does, when you perform `uiElement.text().contains("Something")`.

. Find web element using WebDriver
. Check if element is present
. Retrieve the text of the element
. If the text does not contain "Something", start over with 1.
. Otherwise when the timeout has reached, an assertion error message will be displayed that the
text of the element you're looking for doesn't contain the string "Something".

==== More consistence, less complexity

There will be only one interface for everything you need in a manner of
an easy to read fluent API. It is not too abstract like TestNG Assert, and not to technically like AssertJ.

The new interface will always act exactly like you expect to, no matter in which context you are.
You don't have to decide which method you should use. The standard way will be the best fit for most cases. Let the framework handle the workarrounds for you.

==== Strict Page Object pattern

Testerra was built with the Page Object pattern in mind. The new API makes it easier for your team, to keep you on track
makes it harder to break out, even if your project contains hundreds of Pages and thousands of Tests.

The new components extension allows you to implement Page Objects like the Web Developer would do by separating
functionality into reusable components.

==== Smaller codebase and less boilerplate
The API provides abstract assertion implementations for several properties.

. `StringAssertion` allows you to perform assertions on strings like `contains("Something")`
. `QuantityAssertion` allows you to perform assertions on quantified values like `isBetween(-2,3)`
. `BinaryAssertion` allows to assert if an value is boolean or a string that represents a boolean value with `is(true)`

These generic assertions are used in many other assertions and supports a hierarchical order.
This is what the hierarchy looks like when you perform `uiElement.screenshot().file().extension().is("png")`

. Take a screenshot and return a `ScreenshotAssertion`
. Return a generic `FileAssertion` with the taken screenshot file
. Return a generic `StringAssertion` with the given file name extension

This implementation helps to keep the internal assertion code small, easy extensible and maintainable.

==== Dependency Injection

We want to make Testerra more SOLID. Thats why we finally introduced Dependency Injection via. Google Guice.
